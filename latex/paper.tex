\documentclass{ifacconf}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{natbib}

\bibpunct{(}{)}{;}{a}{,}{}

\usepackage{color}
\usepackage{listings}
\lstset{ %
language=Python, 
basicstyle=\footnotesize,
numbers=left,
numberstyle=\tiny,
xleftmargin= 10pt,
stepnumber=1,
numbersep=5pt,
backgroundcolor=\color{white}, 
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=none,
tabsize=2,
captionpos=b,
breaklines=true,
breakatwhitespace=false,
escapeinside={\%}{)}
}

\begin{document}
\begin{frontmatter}
\title{Simulation of 2D physics of hand drawn objects using OpenCV and Box2D}
\author[Bratislava]{Michal Sedlák}
\address[Bratislava]{Faculty of Electrical Engineering and Information
Technology, Slovak University of Technology, Ilkovičova 3, 812 19 Bratislava,
Slovakia
\\
(e-mail: michal.sedlak@stuba.sk)}
\begin{abstract}
%TODO Napisat abstrakt

\end{abstract}
\begin{keyword}
Maximum 5 keywords.
\end{keyword}
\end{frontmatter}

\section{Introduction}
This paper describes applying of Newtonian physics to hand drawn objects
recognized in image from camera. Simulation of physics is used in many modern
applications. You can find in implementations used by 3D drawing and animation
programs, more complex used in game engines or exact and precise simulation in
CAE programs. Paper describes process of animation of hand drawn object, from a
capturing phase, over recognition of the objects, interpretation objects in
physical engine, to animation of such objects. This approach can be applied in
education of physics at elementary schools, with interactive blackboards, or in
computer games.

\section{Object detection and Open Computer Vision library}
To apply a physics to hand drawn objects we need to identify and isolate
objects from image. We have used a web camera as a source and Open Computer
Vision library as processing tool of the images.

\subsection{OpenCV}
In regards the book of \cite{OpenCV} OpenCV  is a library for open source
programming functions for real time computer vision, with more than five hundred
optimized algorithms. It can be used with C++, C and Python. We chose Python for
implementation in our application.

Simple image capture is shown in Listing \ref{Capture}.
\begin{lstlisting}[caption=Query image frame from web camera, label=Capture]
self.camera = cv.CaptureFromCAM(-1) %\label{Capture:init})
self.image = cv.QueryFrame(self.camera) %\label{Capture:query})
self.DetectOutline(self.image)
\end{lstlisting}
In line \ref{Capture:init} of listing \ref{Capture} we initialize our web
camera. In variable camera is allocated and initialized object that can query
camera for new image. Then as we see in \ref{Capture:query} we can get the
image from camera and store it in the variable named image. Now when we have
image data stored in the variable, we can process data to find outlines.
\begin{lstlisting}[caption=Outline detection, label=Detect]
def DetectOutline(self, image):
  image_size = cv.GetSize(image)
  grayscale = cv.CreateImage(image_size, 8, 1)	%\label{Detect:grayscale})
  cv.CvtColor(image, grayscale, cv.CV_BGR2GRAY)
  cv.EqualizeHist(grayscale, grayscale)	%\label{Detect:equalize})
  storage = cv.CreateMemStorage(0)
  cv.Threshold(grayscale, grayscale, 50, 255, cv.CV_THRESH_BINARY) %\label{Detect:threshold})
  self.contours = cv.FindContours(grayscale, %\label{Detect:contours})
    cv.CreateMemStorage(),
    cv.CV_RETR_TREE,
    cv.CV_CHAIN_APPROX_SIMPLE)
  if len(self.contours) > 0:
    self.contours = cv.ApproxPoly (self.contours, %\label{Detect:approx})
      storage,
      cv.CV_POLY_APPROX_DP,
      1.5,
      1)
  return self.contours
\end{lstlisting}
In function in Listing \ref{Detect} is shown how to find outlines of objects in
image. We convert image to gray scale as seen on line \ref{Detect:grayscale}.
Then we run histogram equalization (line: \ref{Detect:equalize}).
Equalization makes objects better visible and gives better output for
thresholding (line: \ref{Detect:threshold}) which makes black and white image
prepared for outline detection (line: \ref{Detect:contours}).
%TODO Doplnit obrazok s normalizaciou histogramu
%TODO Doplnit obrazok s thresholdom
After outline detection we have tree of contours stored in the variable
self.contours. These trees are iterable objects sorted from outer to inner
outline connected by property h\_next and v\_next that we will describe in
paragraph about creation of objects from outlines.

Contour can be very complicated and consist of thousands of points, which could
cause too complicated objects. It is time demanding to simulate complicated
objects, that is why we use polynomial approximation of the contour points.
(line:~\ref{Detect:approx}).

Now we have all outlines stored in the outline tree structure, so we can create
objects and apply a physics.
%TODO Doplnit obrazok so zvyraznenymi outlineami

\section{Physics simulation in Box2D}
There is lot of physics engines that can be used for simulation of physics.
Because we wanted to simulate physics only in 2D we could, code our own
implementation of physics, or use one of commercial or open source engines. We
chose Box2D[\cite{GameEngines}], which is open source 2D physiscs engine with
posibility to simulate rigid body objects and their collisions.
\subsection{World}
To create physics simulation we need to create world. World is object that
manages memory, objects and simulation. Creation of world is shown in Listing
\ref{World}:
\begin{lstlisting}[caption=Creation of Box2D world,label=World]
self.worldAABB=box2d.b2AABB()
self.worldAABB.lowerBound = (-100.0, -100.0) %\label{World:lower})
self.worldAABB.upperBound = ( 600.0, 600.0)	%\label{World:upper})
gravity = (0.0, -10.0) %\label{World:gravity})

doSleep = True %\label{World:sleep})
self.world = box2d.b2World(self.worldAABB, gravity, doSleep)
\end{lstlisting}
First we have to create boundaries of the world. We define them as vectors from
bottom left (line: \ref{World:lower}) to top right (line:
\ref{World:upper}). Objects have to be inside the boudaries, when an object
touch the boundary it gets stuck. Then we define gravity vector (line:
\ref{World:gravity}). The last thing before creation of the world we allow
objects to sleep(line: \ref{World:sleep}). Object that are not moving fall
asleep, then are ignored by the engine. Last line of Listing \ref{World} creates
the world.

When we have world created we are ready to create objects from outlines.
\subsection{Objects}
Every object that is simulated in Box2D consists of body and shapes.
\subsubsection{Bodies, shapes and collisions}
Bodies are skelet used by shapes. One body can contain more shapes, but one
shape could be attached to only one body. Box2d is rigid body
physics engine, that mean that shapes attached to body can not move against
other, or body.
\subsection{Tesselation}
Box2D supports only collisions between convex objects. That is why we need to
breake outlines to convex polygons. There is more ways how to break concave
objects. We chose Seidel's Triangulation Algorithm implemented by poly2tri
Python library
%TODO asi iny algorytmus
%TODO pridat referenciu na poly2tri

\subsection{Implementation}
%TODO dat sem zdrojovy kod a popisat ho
\section{Future work}
Identifikacia objektov
Sledovanie objektov a morfing
Interakcia hybucich sa objektov zachytenych kamerov s Box2D reprezentaciou

\section*{Acknowledgments}
The work was supported by a grant (No. NIL-I-007-d) from Iceland, Liechtenstein 
and Norway through the EEA Financial Mechanism and the Norwegian Financial 
Mechanism. This project is also co-financed from the state budget of the Slovak
Republic..

%If you use BibTeX comment the second line, if not comment the first line
\bibliography{pcbib}
%\input{paper.bbl}

\end{document}



